<?xml version="1.0" encoding="UTF-8"?>	<item><status>past</status><description>The March meeting of the Boston MySQL User Group is going to feature a session by Jacob Nikom called:&lt;br /&gt;&lt;br /&gt;Optimizing Concurrent Storage and Retrieval Operations for Real-Time Surveillance Applications &lt;br /&gt;&lt;br /&gt;This talk discusses performance of real-time retrieval operations while doing  concurrent high volume insertion, the proposed DBMS architecture, MySQL server tuning, and the design of the storage/retrieval benchmark. Jacob will show the insertion time from the number of applied indexes. He will also demonstrate the excellent responsiveness of the MySQL server both in simulated and actual surveillance.&lt;br /&gt;&lt;br /&gt;------------------------&lt;br /&gt;&lt;br /&gt;Here is the URL for MIT's Map with the location of this building:&lt;br /&gt;&lt;a href="http://whereis.mit.edu/map-jpg?selection=E40&amp;amp;Buildings=go" target="_blank"&gt;http://whereis.mit.ed...&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;This map shows the MBTA Kendall Stop:&lt;br /&gt;&lt;a href="http://whereis.mit.edu/map-jpg?selection=L5&amp;amp;Landmarks=go" target="_blank"&gt;http://whereis.mit.ed...&lt;/a&gt;&lt;br /&gt;(the stop is in red on that map, and you can see E51 in the bottom right)&lt;br /&gt;&lt;br /&gt;Here are the URL's for the parking lots:&lt;br /&gt;&lt;a href="http://whereis.mit.edu/map-jpg?selection=P4&amp;amp;Parking=go" target="_blank"&gt;http://whereis.mit.ed...&lt;/a&gt;&lt;br /&gt;&lt;a href="http://whereis.mit.edu/map-jpg?selection=P5&amp;amp;Parking=go" target="_blank"&gt;http://whereis.mit.ed...&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;Free pizza and soda will be served, so please RSVP accurately.&lt;br /&gt;&lt;br /&gt;To RSVP anonymously, please login to the Meetup site with the e-mail address &amp;quot;admin at sheeri dot com&amp;quot; and the password &amp;quot;guest&amp;quot;.&lt;br /&gt;&lt;br /&gt;For more information, see:  &lt;a href="http://mysql.meetup.com/137/"&gt;http://mysql.meetup.c...&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;More information about the talk, from Jacob:&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;Surveillance applications continuously collect data from sensors, store them in the database management system (DBMS), and retrieve them to detect important events in the environment.  High-rate input data streams combined with large database sizes make the task of retrieving data in real-time very challenging.  &lt;br /&gt;&lt;br /&gt;To prevent the database from becoming a bottleneck for the whole system the storage operations have to be performed in real time demanding quick data insertion.   Regardless of the database size the data search also has to be quick to allow interactive dialog with application. Since both operations share the same resources the gain of one task is the pain of another. &lt;br /&gt;&lt;br /&gt;Concurrent execution of storage and retrieval operations produces fundamentally contradictory requirements. Indexes are necessary to minimize the retrieval time.  However, index usage increases the insertion time due to the index rearrangement. It also adds more disks I/O due to the index file growth. What is the best way to balance these conflicting demands?   &lt;br /&gt;&lt;br /&gt;The designers of data warehouses approached this problem by splitting the DBMS in two parts: Operational Data Store (ODS), where the tables are dynamically updated by transactions and Data Warehouse (DWH) with static tables for analytical queries. Since each part uses different database server, the storage and retrieval operations execute separately, eliminating concurrency and conflicting requirements. However, this separation creates &amp;quot;latency problem&amp;quot;, because the search in the DWH does not include the latest data stored in the ODS. This drawback makes such architecture unacceptable for real-time surveillance applications. &lt;br /&gt;&lt;br /&gt;Therefore our system took a different approach. We merged ODS and DWH and tuned MySQL server for both insertion and retrieval operations. This decision was based on the fact that after insertion of only one record the index update time is relatively short.  Proportionally, index update after each operation during continuous insertion of new records does not increase the overall storage time significantly.  &lt;br /&gt;&lt;br /&gt;To verify the scalability of this observation we measured the performance of the concurrent storage/retrieval operations for different database sizes. The benchmark results showed that although the decrease of the insertion performance due to indexing is significant, it is not dramatic. Therefore the guaranteed search time is achievable even in the case of tens of millions stored records.&lt;br /&gt;</description><event_hosts><event_hosts_item><member_name>Sheeri Kritzer Cabral</member_name><member_id>2380684</member_id></event_hosts_item></event_hosts><maybe_rsvp_count>10</maybe_rsvp_count><waitlist_count>0</waitlist_count><updated>1239666761000</updated><rating><average>4.67000007629</average><count>9</count></rating><group><who>Boston-Metro MySQL Users</who><join_mode>open</join_mode><urlname>mysqlbos</urlname><id>212864</id><group_lat>42.3400001526</group_lat><group_lon>-71.0699996948</group_lon><name>The Boston MySQL Meetup Group</name></group><yes_rsvp_count>32</yes_rsvp_count><created>1233795859000</created><visibility>public</visibility><name>The Boston MySQL March Meetup</name><id>9675782</id><headcount>23</headcount><utc_offset>-14400000</utc_offset><time>1236639600000</time><event_url>http://www.meetup.com/mysqlbos/events/9675782/</event_url></item>